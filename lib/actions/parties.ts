"use server";

import { and, desc, eq, getTableColumns, ilike, isNull, or } from "drizzle-orm";
import { revalidatePath, revalidateTag } from "next/cache";
import { getUserProfile } from "@/lib/actions/member";
import { db, getDbReadOnly } from "@/lib/db/connection";
import { parties, userProfiles, users } from "@/lib/db/schema";
import type {
  CreatePartyData,
  Party,
  PartyFilters,
  UpdatePartyData,
} from "@/lib/types/parties";

// Helper to generate party UUID
// Uses PostgreSQL's gen_random_uuid() via Drizzle's defaultRandom()
async function generatePartyId(): Promise<string> {
  // UUID is auto-generated by database default, but we need it for the insert
  // Import crypto for UUID generation
  const { randomUUID } = await import("crypto");
  return randomUUID();
}

// Helper to convert PostgreSQL party row to Party object
// Converts Date timestamps to number (milliseconds since epoch) for backward compatibility
// UUIDs are returned as strings (no conversion needed)
function pgRowToParty(row: {
  id: string; // UUID
  name: string;
  description: string | null;
  websiteUrl: string | null;
  foundedBy: string; // UUID
  leaderUsername: string;
  createdAt: Date;
  updatedAt: Date;
  dissolvedAt: Date | null;
}): Party {
  return {
    id: row.id, // UUID as string
    name: row.name,
    description: row.description || undefined,
    websiteUrl: row.websiteUrl || undefined,
    foundedBy: row.foundedBy, // UUID as string
    leaderUsername: row.leaderUsername,
    createdAt: row.createdAt.getTime(),
    updatedAt: row.updatedAt.getTime(),
  };
}

// Helper function to get user UUID from session
async function getUserUuidFromSession(): Promise<string> {
  const { auth } = await import("@/lib/auth");
  const session = await auth();

  if (!session || !session.user || !session.user.id) {
    throw new Error("Authentication required");
  }

  const authUserId = parseInt(String(session.user.id), 10);

  // Get UUID from users table
  const [user] = await db
    .select({ uuid: users.uuid })
    .from(users)
    .where(eq(users.id, authUserId))
    .limit(1);

  if (!user || !user.uuid) {
    throw new Error("User UUID not found");
  }

  return user.uuid;
}

// Party CRUD Operations

export async function createParty(data: CreatePartyData) {
  try {
    // Get UUID from session
    const userUuid = await getUserUuidFromSession();

    // Validation
    if (!data.name?.trim()) {
      return {
        success: false,
        error: "Name is required",
      };
    }

    // Check if user already founded a party and dissolve it if they have
    const [existingParty] = await db
      .select({ id: parties.id })
      .from(parties)
      .where(and(eq(parties.foundedBy, userUuid), isNull(parties.dissolvedAt)))
      .limit(1);

    if (existingParty) {
      // Dissolve the existing party before creating a new one
      await db
        .update(parties)
        .set({ dissolvedAt: new Date() })
        .where(eq(parties.id, existingParty.id));
    }

    // Ensure user profile exists (will be created if it doesn't)
    const profileResult = await getUserProfile();
    if (!profileResult.success || !profileResult.profile?.username) {
      return {
        success: false,
        error: "User profile not found",
      };
    }

    const username = profileResult.profile.username;

    const partyId = await generatePartyId();
    const now = new Date();

    // Insert new party with denormalized leader username
    await db.insert(parties).values({
      id: partyId,
      name: data.name.trim(),
      description: data.description?.trim() || null,
      websiteUrl: data.websiteUrl?.trim() || undefined,
      foundedBy: userUuid,
      leaderUsername: username,
      createdAt: now,
      updatedAt: now,
      dissolvedAt: null,
    });

    // Revalidate paths and cache tags that show party/parties data
    revalidatePath("/[lang]/parties", "page");
    revalidatePath("/[lang]/parties/[id]", "page");
    revalidateTag("parties-list", "default");

    return { success: true, partyId };
  } catch (error) {
    console.error("Error creating party:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Failed to create party",
    };
  }
}

export async function getParty(partyId: string): Promise<Party | null> {
  try {
    // Use read-only DB (HTTP driver) for better performance
    const readDb = getDbReadOnly();
    const [partyRow] = await readDb
      .select(getTableColumns(parties))
      .from(parties)
      .where(eq(parties.id, partyId))
      .limit(1);

    if (!partyRow) {
      return null;
    }

    const party = pgRowToParty(partyRow);
    return party;
  } catch (error) {
    console.error(`[getParty] Error getting party ${partyId}:`, error);
    return null;
  }
}

export async function updateParty(
  partyId: string,
  data: UpdatePartyData,
): Promise<{ success: boolean; error?: string }> {
  try {
    // Get UUID from session
    const userUuid = await getUserUuidFromSession();

    // Get party to verify ownership
    const party = await getParty(partyId);
    if (!party) {
      return { success: false, error: "Party not found" };
    }

    if (party.foundedBy !== userUuid) {
      return {
        success: false,
        error: "Only the party founder can update the party",
      };
    }

    const pgUpdates: {
      name?: string;
      description?: string | null;
      websiteUrl?: string | null;
      updatedAt: Date;
    } = {
      updatedAt: new Date(),
    };

    if (data.name !== undefined) {
      if (!data.name.trim()) {
        return { success: false, error: "Name cannot be empty" };
      }
      pgUpdates.name = data.name.trim();
    }

    if (data.description !== undefined) {
      pgUpdates.description = data.description.trim() || null;
    }

    if (data.websiteUrl !== undefined) {
      pgUpdates.websiteUrl = data.websiteUrl.trim() || null;
    }

    await db.update(parties).set(pgUpdates).where(eq(parties.id, partyId));

    // Revalidate paths and cache tags that show party/parties data
    revalidatePath("/[lang]/parties", "page");
    revalidatePath(`/[lang]/parties/${partyId}`, "page");
    revalidateTag("parties-list", "default");

    return { success: true };
  } catch (error) {
    console.error("Error updating party:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Failed to update party",
    };
  }
}

export async function deleteParty(
  partyId: string,
): Promise<{ success: boolean; error?: string }> {
  try {
    // Get UUID from session
    const userUuid = await getUserUuidFromSession();

    const party = await getParty(partyId);
    if (!party) {
      return { success: false, error: "Party not found" };
    }

    if (party.foundedBy !== userUuid) {
      return {
        success: false,
        error: "Only the party founder can dissolve the party",
      };
    }

    // Set dissolvedAt timestamp (soft delete)
    await db
      .update(parties)
      .set({ dissolvedAt: new Date() })
      .where(eq(parties.id, partyId));

    // Revalidate paths and cache tags that show party/parties data
    revalidatePath("/[lang]/parties", "page");
    revalidatePath("/[lang]/parties/[id]", "page");
    revalidateTag("parties-list", "default");

    return { success: true };
  } catch (error) {
    console.error("Error deleting party:", error);
    return {
      success: false,
      error:
        error instanceof Error ? error.message : "Failed to dissolve party",
    };
  }
}

// Party Discovery

export async function getParties(filters?: PartyFilters): Promise<Party[]> {
  const startTime = performance.now();
  try {
    const limit = filters?.limit || 1000;
    const offset = filters?.offset || 0;

    // Build query conditions
    let whereCondition = isNull(parties.dissolvedAt); // Only active parties

    // Add search filter if provided
    if (filters?.search) {
      const searchPattern = `%${filters.search}%`;
      whereCondition = and(
        whereCondition,
        or(
          ilike(parties.name, searchPattern),
          ilike(parties.description, searchPattern),
        )!,
      )!;
    }

    // Query PostgreSQL: active parties, ordered by createdAt DESC (newest first)
    // Use read-only DB (HTTP driver) for better performance on read queries
    const readDb = getDbReadOnly();
    const partyRows = await readDb
      .select(getTableColumns(parties))
      .from(parties)
      .where(whereCondition)
      .orderBy(desc(parties.createdAt))
      .limit(limit)
      .offset(offset);

    // Convert PostgreSQL rows to Party objects
    return partyRows.map(pgRowToParty);
  } catch (error) {
    console.error(
      `[getParties] Error after ${(performance.now() - startTime).toFixed(2)}ms:`,
      error,
    );
    return [];
  }
}

// User Party Operations

export async function getUserParty(): Promise<Party | null> {
  try {
    // Get UUID from session
    const userUuid = await getUserUuidFromSession();
    const readDb = getDbReadOnly();

    const [partyRow] = await readDb
      .select(getTableColumns(parties))
      .from(parties)
      .where(and(eq(parties.foundedBy, userUuid), isNull(parties.dissolvedAt)))
      .limit(1);

    if (!partyRow) {
      return null;
    }

    return pgRowToParty(partyRow);
  } catch (error) {
    console.error("Error getting user party:", error);
    return null;
  }
}
